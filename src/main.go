package main

import (
	"encoding/json"
	"io"
	"log"
	"time"

	"github.com/baldator/vega-bot/social"
	"github.com/baldator/vega-bot/socialevents"

	"github.com/getsentry/sentry-go"
	"github.com/vegaprotocol/api-clients/go/generated/code.vegaprotocol.io/vega/proto"
	"github.com/vegaprotocol/api-clients/go/generated/code.vegaprotocol.io/vega/proto/api"
	"golang.org/x/net/context"
	"google.golang.org/grpc"
)

func main() {
	// Read application config
	conf, err := ReadConfig("config.yaml")
	if err != nil {
		log.Fatal("Failed to read config: ", err)
	}

	if conf.SentryEnabled {
		initializeSentry(conf.SentryDsn)
	}

	if conf.PrometheusEnabled {
		initializePrometheus(conf.PrometheusPort)
	}

	if conf.BotBlacklistEnabled {
		initializeBots()
	}

	func() {
		if conf.SentryEnabled {
			defer sentry.Recover()
		}

		log.Println("Starting server")
		log.Println("Initialize social webservice connection")
		if conf.Debug {
			confJson, _ := json.Marshal(conf)
			log.Printf("Configuration: %s\n", confJson)

		}

		socialPost, err := social.NewSocialChannel(conf.SocialServiceURL, conf.SocialServiceKey, conf.SocialServiceSecret, conf.SocialTwitterEnabled, conf.SocialDiscordEnabled, conf.SocialSlackEnabled, conf.SocialTelegramEnabled)
		if err != nil {
			logError(err, conf.SentryEnabled)
		}

		conn, err := grpc.Dial(conf.GrpcNodeURL, grpc.WithInsecure(), grpc.WithDefaultCallOptions(grpc.MaxCallRecvMsgSize(256<<22)))
		if err != nil {
			logError(err, conf.SentryEnabled)
		}
		defer conn.Close()

		dataClient := api.NewTradingDataServiceClient(conn)
		eventType := []proto.BusEventType{}

		if conf.VegaNetworkParametersEnabled == true {
			go func() {
				for {
					flagReset, uptime, err := vegaNetworkReset(dataClient)
					if err != nil {
						logError(err, conf.SentryEnabled)
					}
					if flagReset {
						message, err := socialevents.NetworkResetNotification(uptime)
						if err != nil {
							logError(err, conf.SentryEnabled)
						}
						if message != "" {
							socialPost.SendMessage(message)

							// reinitialize network parameters
							err = writeUptimeConfig(uptime)
							if err != nil {
								logError(err, conf.SentryEnabled)
							}
						} else {
							log.Println("Network start time didn't change since last run")
						}
					}
					time.Sleep(60 * time.Second)
				}
			}()
		}
		if conf.VegaLossSocializationEnabled == true {
			eventType = append(eventType, proto.BusEventType_BUS_EVENT_TYPE_LOSS_SOCIALIZATION)
		}
		if conf.VegaAuctionsEnabled == true {
			eventType = append(eventType, proto.BusEventType_BUS_EVENT_TYPE_AUCTION)
		}
		if conf.VegaProposalsEnabled == true {
			eventType = append(eventType, proto.BusEventType_BUS_EVENT_TYPE_PROPOSAL)
		}
		if conf.VegaTradesEnabled == true {
			eventType = append(eventType, proto.BusEventType_BUS_EVENT_TYPE_TRADE)
		}
		if conf.VegaOrdersEnabled == true {
			eventType = append(eventType, proto.BusEventType_BUS_EVENT_TYPE_ORDER)
		}

		events, err := dataClient.ObserveEventBus(context.Background())

		// check if network ID changed since last run
		previousEthereumConfig, err := readPreviousEthereumConfig(dataClient)
		if err != nil {
			logError(err, conf.SentryEnabled)
		}

		currentEthereumConfig, err := readEthereumConfig(dataClient)
		if err != nil {
			logError(err, conf.SentryEnabled)
		}

		message := socialevents.NetworkParametesNotification(dataClient, currentEthereumConfig, previousEthereumConfig)
		if message != "" {
			socialPost.SendMessage(message)

			// reinitialize network parameters
			err = writeEthereumConfig(currentEthereumConfig)
			if err != nil {
				logError(err, conf.SentryEnabled)
			}
		} else {
			log.Println("Network ID didn't change since last run")
		}

		done := make(chan bool)
		go func() {
			for {
				resp, err := events.Recv()

				if err == io.EOF {
					close(done)
					return
				}

				if err != nil {
					logError(err, conf.SentryEnabled)
				}

				for _, event := range resp.Events {
					switch eventTypeLoop := event.Type; eventTypeLoop {
					case proto.BusEventType_BUS_EVENT_TYPE_NETWORK_PARAMETER: // Network has been reset (network ID has changed/block height reset)
						networkParameter := event.GetNetworkParameter()
						if networkParameter.Key == "blockchains.ethereumConfig" {
							message := socialevents.NetworkParametesNotification(dataClient, networkParameter, currentEthereumConfig)
							if message != "" {
								if conf.Debug {
									printEvent(event)
								}
								socialPost.SendMessage(message)

								// reinitialize network parameters
								err = writeEthereumConfig(networkParameter)
								if err != nil {
									logError(err, conf.SentryEnabled)
								}
							}
						}
					case proto.BusEventType_BUS_EVENT_TYPE_LOSS_SOCIALIZATION: // Loss socialisation alerts (distribution of funds generated by defaulting traders)
						if conf.Debug {
							printEvent(event)
						}
						lossSocialization := event.GetLossSocialization()
						message, err := socialevents.LossSocializationNotification(dataClient, lossSocialization)
						if err != nil {
							logError(err, conf.SentryEnabled)
						}
						log.Println(message)
						socialPost.SendMessage(message)
					case proto.BusEventType_BUS_EVENT_TYPE_AUCTION: // Market price monitoring auction started/ended
						if conf.Debug {
							printEvent(event)
						}
						auction := event.GetAuction()
						message, err := socialevents.AuctionNotification(dataClient, auction, conf.VegaAuctionsExtendEnabled)
						log.Println(message)
						if err != nil {
							logError(err, conf.SentryEnabled)
						}
						socialPost.SendMessage(message)
					case proto.BusEventType_BUS_EVENT_TYPE_PROPOSAL: //New Market Proposal created, updated, enacted
						if conf.Debug {
							printEvent(event)
						}
						proposal := event.GetProposal()
						message, err := socialevents.MarketProposalNotification(dataClient, proposal.Id, proposal.State)
						if err != nil {
							logError(err, conf.SentryEnabled)
						}
						log.Println(message)
						socialPost.SendMessage(message)
					case proto.BusEventType_BUS_EVENT_TYPE_TRADE: // Rekt alert
						trade := event.GetTrade()
						if trade.Type == proto.Trade_TYPE_NETWORK_CLOSE_OUT_BAD {
							if conf.Debug {
								printEvent(event)
							}
							message, err := socialevents.RektNotification(dataClient, trade)
							if err != nil {
								logError(err, conf.SentryEnabled)
							}
							log.Println(message)
							socialPost.SendMessage(message)
						}
					case proto.BusEventType_BUS_EVENT_TYPE_ORDER: // Whale alert
						order := event.GetOrder()
						if order.Status == proto.Order_STATUS_ACTIVE {
							value := order.Size * order.Price
							marketVal, marketFlag, _ := getMarketValue(dataClient, order.MarketId, order.Side, conf.WhaleOrdersThreshold)
							if float64(value) > (float64(marketVal)*conf.WhaleThreshold) && marketFlag {
								if conf.Debug {
									printEvent(event)
								}

								if conf.BotBlacklistEnabled {
									if isBot(order.PartyId) {
										log.Printf("Party id %s is in the blacklist. Ignoring...", order.PartyId)
										break
									} else {
										log.Printf("Party id %s is not in the blacklist. Continuing...", order.PartyId)

									}
								}
								message, err := socialevents.WhaleNotification(dataClient, order)
								if err != nil {
									logError(err, conf.SentryEnabled)
								}
								log.Println(message)
								socialPost.SendMessage(message)

							}
						}
					case proto.BusEventType_BUS_EVENT_TYPE_MARKET_CREATED:
						log.Println("BusEventType_BUS_EVENT_TYPE_MARKET_CREATED: ", event)

					}
				}
			}
		}()

		// When the batchSize is too small -> "rpc error: code = Unknown desc = EOF"
		log.Printf("Listening to event types: %v\n", eventType)
		observerEvent := api.ObserveEventBusRequest{Type: eventType, BatchSize: conf.VegaEventsBatchSize}
		events.Send(&observerEvent)
		events.CloseSend()

		<-done //we will wait until all response is received

		log.Println("finished")
	}()
}
