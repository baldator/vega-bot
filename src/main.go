package main

import (
	"io"
	"log"

	"github.com/baldator/vega-alerts/social"
	"github.com/baldator/vega-alerts/socialevents"

	"github.com/getsentry/sentry-go"
	"github.com/vegaprotocol/api-clients/go/generated/code.vegaprotocol.io/vega/proto"
	"github.com/vegaprotocol/api-clients/go/generated/code.vegaprotocol.io/vega/proto/api"
	"golang.org/x/net/context"
	"google.golang.org/grpc"
)

func main() {
	// Read application config
	conf, err := ReadConfig("config.yaml")
	if err != nil {
		log.Fatal("Failed to read config: ", err)
	}

	if conf.SentryEnabled {
		initializeSentry(conf.SentryDsn)
	}

	if conf.PrometheusEnabled {
		initializePrometheus(conf.PrometheusPort)
	}

	func() {
		if conf.SentryEnabled {
			defer sentry.Recover()
		}

		log.Println("Starting server")
		log.Println("Initialize social webservice connection")

		socialPost, err := social.NewSocialChannel(conf.SocialServiceURL, conf.SocialServiceKey, conf.SocialServiceSecret, conf.SocialTwitterEnabled, conf.SocialDiscordEnabled, conf.SocialSlackEnabled, conf.SocialTelegramEnabled)
		if err != nil {
			logError(err, conf.SentryEnabled)
		}

		conn, err := grpc.Dial(conf.GrpcNodeURL, grpc.WithInsecure(), grpc.WithDefaultCallOptions(grpc.MaxCallRecvMsgSize(256<<22)))
		if err != nil {
			logError(err, conf.SentryEnabled)
		}
		defer conn.Close()

		dataClient := api.NewTradingDataServiceClient(conn)
		eventType := []proto.BusEventType{}

		if conf.VegaNetworkParametersEnabled {
			eventType = append(eventType, proto.BusEventType_BUS_EVENT_TYPE_NETWORK_PARAMETER)
		}
		if conf.VegaLossSocializationEnabled {
			eventType = append(eventType, proto.BusEventType_BUS_EVENT_TYPE_LOSS_SOCIALIZATION)
		}
		if conf.VegaAuctionsEnabled {
			eventType = append(eventType, proto.BusEventType_BUS_EVENT_TYPE_AUCTION)
		}
		if conf.VegaProposalsEnabled {
			eventType = append(eventType, proto.BusEventType_BUS_EVENT_TYPE_PROPOSAL)
		}
		if conf.VegaTradesEnabled {
			eventType = append(eventType, proto.BusEventType_BUS_EVENT_TYPE_TRADE)
		}
		if conf.VegaOrdersEnabled {
			eventType = append(eventType, proto.BusEventType_BUS_EVENT_TYPE_ORDER)
		}

		events, err := dataClient.ObserveEventBus(context.Background())

		currentEthereumConfig, err := readEthereumConfig(dataClient)
		if err != nil {
			logError(err, conf.SentryEnabled)
		}

		done := make(chan bool)
		go func() {
			for {
				resp, err := events.Recv()

				if err == io.EOF {
					close(done)
					return
				}

				if err != nil {
					logError(err, conf.SentryEnabled)
				}

				for _, event := range resp.Events {
					switch eventTypeLoop := event.Type; eventTypeLoop {
					case proto.BusEventType_BUS_EVENT_TYPE_NETWORK_PARAMETER: // Network has been reset (network ID has changed/block height reset)
						networkParameter := event.GetNetworkParameter()
						if networkParameter.Key == "blockchains.ethereumConfig" {
							message := socialevents.NetworkParametesNotification(dataClient, networkParameter, currentEthereumConfig)
							if message != "" {
								log.Println(message)
								socialPost.SendMessage(message)

								// reinitialize network parameters
								currentEthereumConfig, err = readEthereumConfig(dataClient)
								if err != nil {
									logError(err, conf.SentryEnabled)
								}
							}
						}
					case proto.BusEventType_BUS_EVENT_TYPE_LOSS_SOCIALIZATION: // Loss socialisation alerts (distribution of funds generated by defaulting traders)
						lossSocialization := event.GetLossSocialization()
						message, err := socialevents.LossSocializationNotification(dataClient, lossSocialization)
						if err != nil {
							logError(err, conf.SentryEnabled)
						}
						log.Println(message)
						socialPost.SendMessage(message)
					case proto.BusEventType_BUS_EVENT_TYPE_AUCTION: // Market price monitoring auction started/ended
						auction := event.GetAuction()
						message, err := socialevents.AuctionNotification(dataClient, auction)
						log.Println(message)
						if err != nil {
							logError(err, conf.SentryEnabled)
						}
						socialPost.SendMessage(message)
					case proto.BusEventType_BUS_EVENT_TYPE_PROPOSAL: //New Market Proposal created, updated, enacted
						log.Println("BUS_EVENT_TYPE_PROPOSAL: ", event)
						proposal := event.GetProposal()
						message, err := socialevents.MarketProposalNotification(dataClient, proposal.Id, proposal.State)
						if err != nil {
							logError(err, conf.SentryEnabled)
						}
						log.Println(message)
						socialPost.SendMessage(message)
					case proto.BusEventType_BUS_EVENT_TYPE_TRADE: // Rekt alert
						trade := event.GetTrade()
						if trade.Type == proto.Trade_TYPE_NETWORK_CLOSE_OUT_BAD {
							message, err := socialevents.RektNotification(dataClient, trade)
							if err != nil {
								logError(err, conf.SentryEnabled)
							}
							log.Println(message)
							socialPost.SendMessage(message)
						}
					case proto.BusEventType_BUS_EVENT_TYPE_ORDER: // Whale alert
						order := event.GetOrder()
						if order.Status == proto.Order_STATUS_ACTIVE {
							value := order.Size * order.Price
							marketVal, marketFlag, _ := getMarketValue(dataClient, order.MarketId, order.Side, conf.WhaleOrdersThreshold)
							if float64(value) > (float64(marketVal)*conf.WhaleThreshold) && marketFlag {
								message, err := socialevents.WhaleNotification(dataClient, order)
								if err != nil {
									logError(err, conf.SentryEnabled)
								}
								log.Println(message)
								socialPost.SendMessage(message)

							}
						}
					case proto.BusEventType_BUS_EVENT_TYPE_MARKET_CREATED:
						log.Println("BusEventType_BUS_EVENT_TYPE_MARKET_CREATED: ", event)

					}
				}
			}
		}()

		// When the batchSize is too small -> "rpc error: code = Unknown desc = EOF"
		observerEvent := api.ObserveEventBusRequest{Type: eventType, BatchSize: conf.VegaEventsBatchSize}
		events.Send(&observerEvent)
		events.CloseSend()

		<-done //we will wait until all response is received

		log.Println("finished")
	}()
}
